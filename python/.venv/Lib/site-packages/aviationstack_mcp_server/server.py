import asyncio
import os
import httpx
from mcp.server import Server, NotificationOptions
from mcp.server.models import InitializationOptions
from mcp.types import Tool, TextContent, EmbeddedResource
import mcp.server.stdio
from typing import Any, Dict, List, Optional

# Constants
BASE_URL = "http://api.aviationstack.com/v1/"
API_KEY = os.environ.get("AVIATIONSTACK_API_KEY")

server = Server("aviationstack-mcp-server")

async def fetch_aviation_data(endpoint: str, params: Dict[str, Any]) -> Dict[str, Any]:
    if not API_KEY:
        raise ValueError("AVIATIONSTACK_API_KEY environment variable is not set")
    
    params["access_key"] = API_KEY
    async with httpx.AsyncClient() as client:
        response = await client.get(f"{BASE_URL}{endpoint}", params=params)
        response.raise_for_status()
        return response.json()

@server.list_tools()
async def handle_list_tools() -> List[Tool]:
    return [
        Tool(
            name="get_flights",
            description="Get real-time and historical flight data.",
            inputSchema={
                "type": "object",
                "properties": {
                    "flight_status": {"type": "string", "enum": ["scheduled", "active", "landed", "cancelled", "incident", "diverted"]},
                    "flight_date": {"type": "string", "description": "Date in YYYY-MM-DD format"},
                    "dep_iata": {"type": "string", "description": "Departure airport IATA code"},
                    "arr_iata": {"type": "string", "description": "Arrival airport IATA code"},
                    "airline_name": {"type": "string"},
                    "flight_number": {"type": "string"},
                },
            },
        ),
        Tool(
            name="get_airports",
            description="Search for global airports.",
            inputSchema={
                "type": "object",
                "properties": {
                    "search": {"type": "string", "description": "Search query"},
                    "iata_code": {"type": "string"},
                    "icao_code": {"type": "string"},
                    "country_name": {"type": "string"},
                },
            },
        ),
        Tool(
            name="get_airlines",
            description="Search for global airlines.",
            inputSchema={
                "type": "object",
                "properties": {
                    "airline_name": {"type": "string"},
                    "iata_code": {"type": "string"},
                    "icao_code": {"type": "string"},
                },
            },
        ),
        Tool(
            name="get_routes",
            description="Get information about airline routes.",
            inputSchema={
                "type": "object",
                "properties": {
                    "dep_iata": {"type": "string", "description": "Departure airport IATA code"},
                    "arr_iata": {"type": "string", "description": "Arrival airport IATA code"},
                    "airline_name": {"type": "string"},
                },
            },
        ),
        Tool(
            name="get_airplanes",
            description="Get information about specific aircraft.",
            inputSchema={
                "type": "object",
                "properties": {
                    "registration_number": {"type": "string"},
                    "iata_type": {"type": "string"},
                },
            },
        ),
    ]

@server.call_tool()
async def handle_call_tool(name: str, arguments: Dict[str, Any] | None) -> List[TextContent]:
    if not arguments:
        arguments = {}
        
    endpoint_map = {
        "get_flights": "flights",
        "get_airports": "airports",
        "get_airlines": "airlines",
        "get_routes": "routes",
        "get_airplanes": "airplanes",
    }
    
    if name not in endpoint_map:
        raise ValueError(f"Unknown tool: {name}")
    
    endpoint = endpoint_map[name]
    try:
        data = await fetch_aviation_data(endpoint, arguments)
        return [TextContent(type="text", text=str(data))]
    except Exception as e:
        return [TextContent(type="text", text=f"Error fetching data: {str(e)}")]

async def main():
    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            InitializationOptions(
                server_name="aviationstack-mcp-server",
                server_version="0.1.0",
                capabilities=server.get_capabilities(
                    notification_options=NotificationOptions(),
                    experimental_capabilities={},
                ),
            ),
        )

if __name__ == "__main__":
    asyncio.run(main())
